---
title: "[React Docs ver.2] Passing Data Deeply with Context - context로 데이터 깊숙이 전달하기"
date: "2023-09-11"
template: "post"
draft: false
slug: "/posts/react-doc-v2-24"
category: "React"
tags:
  - "React"
description: "리액트 새로운 공식문서를 읽고 정리한 글"
# socialImage: "./media/42-line-bible.jpg"
---

> 🐳 본 게시글은 리액트의 새로운 [공식문서](https://react.dev/learn/passing-data-deeply-with-context#)를 읽고 정리한 글이다.

#### 🐌 목차

- [Overview](#overview)
- [Props전달의 문제](#props전달의-문제)
- [Context : 전달의 대안](#context--전달의-대안)
  - [Step 1 : context 생성](#step-1--context-생성)
  - [Step 2 : context 사용](#step-2--context-사용)
  - [Step 3 : context 제공](#step-3--context-제공)

## Overview

보통 props로 부모 컴포넌트에서 자식 컴포넌트로 정보를 전달한다. 하지만 props를 전달하는 것은 중간에 여러 컴포넌트를 거치거나 앱의 여러 컴포넌트가 같은 정보를 필요로 하는 경우 장황하고 불편할 수 있다. 이 경우 Context를 사용하면 부모 컴포넌트는 아래 트리의 모든 컴포넌트에 일부 정보를 깊이에 상관 없이 제공할 수 있다.

## Props전달의 문제

[Props 전달](https://react.dev/learn/passing-props-to-a-component)은 UI 트리를 통해 데이터를 사용하는 컴포넌트로 데이터를 명시적으로 연결하는 좋은 방법이다.
하지만 트리를 통해 일부 prop을 깊이 전달하거나 많은 컴포넌트에 같은 prop이 필요한 경우 prop전달은 장황하고 불편할 수 있다. 가장 가까운 공통 조상이 데이터가 필요한 컴포넌트에서 멀리 떨어져 있을 수 있고, [state를 높이 끌어올리면](https://react.dev/learn/sharing-state-between-components) <span style="background:#d2cbff">"props drilling"</span>의 상황이 발생할 수 있다.
![image](https://github.com/tamoimi/obsidian/assets/100749520/30863421-5174-4c3e-8749-7c32c839a36a)
props를 전달하지 않고 트리에서 데이터를 필요한 컴포넌트로 “<span style="background:#d2cbff">teleport</span>”할 수 있는 방법이 있다면 좋지 않을까? React의 context 기능을 사용해보자!

## Context : 전달의 대안

Context로 부모 컴포넌트가 아래 전체 트리에 데이터를 제공할 수 있다. context는 다양한 방법으로 사용된다. 아래는 하나의 예시이다. 크기에 대한 `level`을 받아들이는 `Heading`컴포넌트를 생각해보자:

- `App.js`

```js
import Heading from "./Heading.js";
import Section from "./Section.js";

export default function Page() {
  return (
    <Section>
      <Heading level={1}>Title</Heading>
      <Heading level={2}>Heading</Heading>
      <Heading level={3}>Sub-heading</Heading>
      <Heading level={4}>Sub-sub-heading</Heading>
      <Heading level={5}>Sub-sub-sub-heading</Heading>
      <Heading level={6}>Sub-sub-sub-sub-heading</Heading>
    </Section>
  );
}
```

- `Section.js`

```js
export default function Section({ children }) {
  return <section className="section">{children}</section>;
}
```

- `Heading.js`

```js
export default function Heading({ level, children }) {
  switch (level) {
    case 1:
      return <h1>{children}</h1>;
    case 2:
      return <h2>{children}</h2>;
    case 3:
      return <h3>{children}</h3>;
    case 4:
      return <h4>{children}</h4>;
    case 5:
      return <h5>{children}</h5>;
    case 6:
      return <h6>{children}</h6>;
    default:
      throw Error("Unknown level: " + level);
  }
}
```

![image](https://github.com/tamoimi/obsidian/assets/100749520/bf10ee7f-d5bb-4077-849a-1b68724a8671)

같은 `Section` 내의 여러가지 제목이 항상 같은 크기를 갖는다고 가정해 보자:

- `App.js`

```js
import Heading from "./Heading.js";
import Section from "./Section.js";

export default function Page() {
  return (
    <Section>
      <Heading level={1}>Title</Heading>
      <Section>
        <Heading level={2}>Heading</Heading>
        <Heading level={2}>Heading</Heading>
        <Heading level={2}>Heading</Heading>
        <Section>
          <Heading level={3}>Sub-heading</Heading>
          <Heading level={3}>Sub-heading</Heading>
          <Heading level={3}>Sub-heading</Heading>
          <Section>
            <Heading level={4}>Sub-sub-heading</Heading>
            <Heading level={4}>Sub-sub-heading</Heading>
            <Heading level={4}>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

![image](https://github.com/tamoimi/obsidian/assets/100749520/04eb22c4-9dfb-4826-bbf8-5753c8c49fd1)

현재 `level`prop을 `<Heading>`에 따로 전달하고 있다:

```js
<Section>
  <Heading level={3}>About</Heading>
  <Heading level={3}>Photos</Heading>
  <Heading level={3}>Videos</Heading>
</Section>
```

`level`prop을 `<Section>`컴포넌트에 대신 전달하면 더 좋을 것이다. 이렇게 하면 같은 section의 모든 제목이 같은 크기를 갖도록 만들 수 있다:

```js
<Section level={3}>
  <Heading>About</Heading>
  <Heading>Photos</Heading>
  <Heading>Videos</Heading>
</Section>
```

하지만 `<Heading>`컴포넌트가 가장 가까운 `<Section>`의 level을 어떻게 알 수 있을까? **그러기 위해서는 자식이 트리 위 어딘가에서 데이터를 “요청”할 수 있는 방법이 필요하다.**

Props 만으로는 할 수 없고 context를 사용해 세 단계로 진행할 수 있다:

1. context를 <span style="background:#d2cbff">**생성**</span>한다. (heading level에 대한 것이므로 `LevelContext`라고 부를 수 있다.)
2. 데이터가 필요한 컴포넌트에서 해당 context를 <span style="background:#d2cbff">**사용**</span>한다. (`Heading`은 `LevelContext`를 사용한다.)
3. 데이터를 지정하는 컴포넌트에서 해당 context를 <span style="background:#d2cbff">**제공**</span>한다. (`Section`은 `LevelContext`를 제공한다).
   Context를 사용해 부모가 내부 트리 전체에 일부 데이터를 제공할 수 있다.
   ![image](https://github.com/tamoimi/obsidian/assets/100749520/82080006-d1f7-46e8-a017-96be41b0eae2)

### Step 1 : context 생성

- 먼저 context를 생성한다. 컴포넌트에서 사용할 수 있도록 **파일에서 내보내기**해야 한다:
- `LevelContext.js`

```js
import { createContext } from "react";

export const LevelContext = createContext(1);
```

`createContext`의 유일한 인수는 <span style="background:#d2cbff">기본 값</span>이다. 여기서 `1`은 가장 큰 heading level을 의미하지만 모든 종류의 값(객체 포함)을 전달할 수 있다.

### Step 2 : context 사용

- React와 context에서 `useContext` Hook을 가져온다:

```js
import { useContext } from "react";

import { LevelContext } from "./LevelContext.js";
```

- 현재 `Heading` 컴포넌트는 props 에서 `level`을 읽는다:

```js
export default function Heading({ level, children }) {
  // ...
}
```

- 대신 `level` prop을 제거하고 방금 import한 context인 `LevelContext`에서 값을 읽는다:

```js
export default function Heading({ children }) {
  const level = useContext(LevelContext);
  // ...
}
```

`useContext`는 Hook이다. `useState` 및 `useReducer`처럼, React 컴포넌트의 최상단에서 Hook을 호출할 수 있다. **`useContext`는 React에게 `Heading` 컴포넌트가 `LevelContext`를 읽기를 원한다고 알려준다.**
이제 `Heading` 컴포넌트에는 `level` prop 이 없기에 더 이상 JSX에서 아래와 같이 `Heading`에 level prop 을 전달할 필요가 없다:

```js
<Section>
  <Heading level={4}>Sub-sub-heading</Heading>
  <Heading level={4}>Sub-sub-heading</Heading>
  <Heading level={4}>Sub-sub-heading</Heading>
</Section>
```

대신 `Section`이 level을 받도록 JSX를 수정한다:

```js
<Section level={4}>
  <Heading>Sub-sub-heading</Heading>
  <Heading>Sub-sub-heading</Heading>
  <Heading>Sub-sub-heading</Heading>
</Section>
```

아래와 같이 수정된 코드를 확인할 수 있다:

- `App.js`

```js
import Heading from "./Heading.js";
import Section from "./Section.js";

export default function Page() {
  return (
    <Section level={1}>
      <Heading>Title</Heading>
      <Section level={2}>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section level={3}>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section level={4}>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

이 예제는 아직 제대로 작동하지 않는다! 왜냐하면 **context를 사용하고 있지만 아직 context를 제공하지 않았기 때문이다.** 그래서 모든 제목의 크기가 같다. React는 어디서 context를 가져와야 할지 모른다!

만약 context를 제공하지 않으면 React는 이전 단계에서 지정한 기본값을 사용한다. 이 예제에서 `createContext`의 인수로 `1`을 지정했기 때문에, `useContext(LevelContext)`는 `1`을 반환하고 모든 제목을 `<h1>`으로 설정한다. 각 `Section`이 자체 context를 제공할 수 있도록 해서 이 문제를 해결해 보자.

### Step 3 : context 제공

- `Section` 컴포넌트는 현재 children을 렌더링한다:

```js
export default function Section({ children }) {
  return <section className="section">{children}</section>;
}
```

- **context provider로 감싸고** `LevelContext`를 제공할 수 있다:

```js
import { LevelContext } from "./LevelContext.js";

export default function Section({ level, children }) {
  return (
    <section className="section">
      <LevelContext.Provider value={level}>{children}</LevelContext.Provider>
    </section>
  );
}
```

이것은 React에게 “이 `<Section>` 안에 있는 컴포넌트가 `LevelContext`를 요청하면 이 `level`을 제공하라.”고 말한다. 컴포넌트는 그 위에 있는 UI 트리에서 가장 가까운`<LevelContext.Provider>`의 값을 사용한다.

원래 코드와 동일한 결과이지만, 각 `Heading` 컴포넌트에 `level` prop을 전달할 필요가 없다! 대신, 위의 가장 가까운 `Section`에 요청하여 제목 level을 “파악”한다:

1. `level` prop을 `<Section>`에 전달한다.
2. `Section`은 section의 children을 `<LevelContext.Provider value={level}>`로 감싼다.
3. `Heading`은 `useContext(LevelContext)`를 사용하여 위의 `LevelContext`값에 가장 가까운 값을 요청한다.

## 같은 컴포넌트에서 context 사용 및 제공

## Context는 중간 컴포넌트를 통과한다

## Context를 사용하기 전

## Context 사용 사례

## 요약
