---
title: "[React Docs ver.2] Extracting State Logic into a Reducer - State로직을 Reducer로 추출하기"
date: "2023-09-07"
template: "post"
draft: false
slug: "/posts/react-doc-v2-23"
category: "React"
tags:
  - "React"
description: "리액트 새로운 공식문서를 읽고 정리한 글"
# socialImage: "./media/42-line-bible.jpg"
---

> 🐳 본 게시글은 리액트의 새로운 [공식문서](https://react.dev/learn/extracting-state-logic-into-a-reducer)를 읽고 정리한 글이다.

🦦 **목차**

- [Overview](#overview)
- [UI 트리](#ui-트리)
- [State는 트리의 한 위치에 묶인다](#state는-트리의-한-위치에-묶인다)
- [동일한 위치의 동일한 컴포넌트는 state를 유지한다](#동일한-위치의-동일한-컴포넌트는-state를-유지한다)
- [동일한 위치의 다른 컴포넌트는 state를 초기화한다](#동일한-위치의-다른-컴포넌트는-state를-초기화한다)
- [같은 위치에서 state 재설정하기](#같은-위치에서-state-재설정하기)
  - [Option 1: 컴포넌트를 다른 위치에 렌더링하기](#option-1-컴포넌트를-다른-위치에-렌더링하기)
  - [Option 2: key로 재설정하기](#option-2-key로-재설정하기)
  - [Key로 재설정하기](#key로-재설정하기)
  - [🐋 DEEP DIVE](#-deep-dive)
- [요약](#요약)

## Overview

여러 개의 state 업데이트가 여러 이벤트 핸들러에 분산되어 있는 컴포넌트는 과부하가 걸릴 수 있다. 이 상황에서 **reducer** 라고 불리는 단일 함수를 통해 컴포넌트 외부의 모든 state 업데이트 로직을 통합할 수 있다.

## reducer로 state로직 통합하기

컴포넌트가 복잡해질수록 어떤 컴포넌트의 state가 업데이트 되는지 찾기 어렵다. 예를 들어 아래의 `TaskApp`컴포넌트는 state에 `tasks`배열을 가지고 있고 세 가지의 이벤트 핸들러를 사용해 tast를 추가, 제거, 수정한다:

```jsx
import { useState } from "react";
import AddTask from "./AddTask.js";
import TaskList from "./TaskList.js";

export default function TaskApp() {
  const [tasks, setTasks] = useState(initialTasks);

  function handleAddTask(text) {
    setTasks([
      ...tasks,
      {
        id: nextId++,
        text: text,
        done: false,
      },
    ]);
  }

  function handleChangeTask(task) {
    setTasks(
      tasks.map((t) => {
        if (t.id === task.id) {
          return task;
        } else {
          return t;
        }
      }),
    );
  }

  function handleDeleteTask(taskId) {
    setTasks(tasks.filter((t) => t.id !== taskId));
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: "Visit Kafka Museum", done: true },
  { id: 1, text: "Watch a puppet show", done: false },
  { id: 2, text: "Lennon Wall pic", done: false },
];
```

![2023-09-07-10-41-24](https://github.com/tamoimi/new-blog/assets/100749520/a7dad360-294a-4cfd-b00c-7c2ec214c5d6)

각 이벤트 핸들러는 state를 업데이트하기 위해 `setTasks`를 부른다. 이 컴포넌트가 커질수록 state로직의 양도 커진다. 복잡성을 줄이고 모든 로직을 접근하기 쉽게 한 곳에 모으기 위해 state 로직을 컴포넌트 외부의 **reducer**라고 하는 단일 함수로 옮길 수 있다.

Reducer는 state를 관리하는 다른 방법이다. 3단계로 `useState`에서 `useReducer`로 마이그레이션할 수 있다.

1. state를 설정하는 것에서 action들을 전달하는 것으로 **변경**하기
2. reducer 함수 **작성**하기
3. 컴포넌트에서 reducer **사용**하기

### Step 1: state 설정을 action들의 전달로 바꾸기

현재 이벤트 핸들러는 state를 설정하여 수행할 작업을 지정하고 있다:

```jsx
function handleAddTask(text) {
  setTasks([
    ...tasks,
    {
      id: nextId++,
      text: text,
      done: false,
    },
  ]);
}

function handleChangeTask(task) {
  setTasks(
    tasks.map((t) => {
      if (t.id === task.id) {
        return task;
      } else {
        return t;
      }
    }),
  );
}

function handleDeleteTask(taskId) {
  setTasks(tasks.filter((t) => t.id !== taskId));
}
```

모든 state 설정 로직을 제거한다. 이제 세 개의 이벤트 핸들러만 남는다:

- 사용자가 “Add”를 누르면 `handleAddTask(text)`가 호출.된다
- 사용자가 task를 토글하거나 “Save”를 누르면 `handleChangeTask(task)`가 호출된다.
- 사용자가 “Delete”를 누르면 `handleDeleteTask(taskId)`가 호출된다.

reducer를 사용한 state 관리는 state를 직접 설정하는 것과 약간 다르다. state를 설정하여 React에 “뭘 할지”를 지시하는 대신, 이벤트 핸들러에서 “action”을 전달해 “사용자가 방금 한일”을 지정한다. (state 업데이트 로직은 다른 곳에 있다!) 이벤트 핸들러를 통해 ”`tasks`를 설정”하는 대신 “task를 추가/변경/삭제”하는 **action**을 전달하는 것이다. 이러한 방식은 사용자의 의도를 더 명확하게 설명한다.

```jsx
function handleAddTask(text) {
  dispatch({
    type: "added",
    id: nextId++,
    text: text,
  });
}

function handleChangeTask(task) {
  dispatch({
    type: "changed",
    task: task,
  });
}

function handleDeleteTask(taskId) {
  dispatch({
    type: "deleted",
    id: taskId,
  });
}
```

`dispatch` 함수에 전달한 객체를 “action” 이라고 한다:

```jsx
function handleDeleteTask(taskId) {
  dispatch(
    // "action" object:
    {
      type: "deleted",
      id: taskId,
    },
  );
}
```

이것은 일반적인 JavaScript 객체다. 어떤걸 넣을지 정할수 있지만 일반적으로 무슨 일이 일어났는지에 대한 최소한의 정보를 포함해야 한다. (`dispatch`함수는 다음 단계에서 추가)

> 📃 **Note**

action 객체는 어떠한 모양이 될 수 있다.

관례에 따라 발생한 일을 설명하는 문자열 `type`을 제공하고 다른 필드에 추가 정보를 전달하는 것이 일반적이다. `type`은 컴포넌트에 따라 다르므로 아래 예제에서는 `'added'` 또는 `'added_task'`를 사용하면 된다. 무슨 일이 일어나는지를 설명할 수 있는 이름을 선택하자!

```jsx
dispatch({
  // specific to component
  type: "what_happened",
  // other fields go here
});
```

### Step 2: reducer함수 작성하기

reducer함수에 state에 로직을 둘 수 있다. 이것은 두 개의 매개변수를 가지는데, 현재state, action객체이다. 그리고 다음 state를 반환한다.

```jsx
function yourReducer(state, action) {
  // return next state for React to set
}
```

React는 reducer에서 반환한 것을 state로 설정할 것이다.

state를 설정하는 로직을 이벤트 핸들러에서 reducer 함수로 옮기기 위해서 다음을 진행하자:

1. 현재 state (`tasks`)를 첫 번째 매개변수로 선언한다.
2. `action` 객체는 두 번째 매개변수로 선언한다.
3. 다음 state를 reducer 함수에서 반환한다. (React가 state로 설정한다.)

아래는 모든 state 설정 로직을 reducer 함수로 옮긴 내용이다:

```jsx
function tasksReducer(tasks, action) {
  if (action.type === "added") {
    return [
      ...tasks,
      {
        id: action.id,
        text: action.text,
        done: false,
      },
    ];
  } else if (action.type === "changed") {
    return tasks.map((t) => {
      if (t.id === action.task.id) {
        return action.task;
      } else {
        return t;
      }
    });
  } else if (action.type === "deleted") {
    return tasks.filter((t) => t.id !== action.id);
  } else {
    throw Error("Unknown action: " + action.type);
  }
}
```

reducer 함수는 state(`tasks`)를 매개변수로 갖기 때문에, **컴포넌트 밖에서 reducer 함수를 선언**할 수 있다. 이렇게 하면 들여쓰기 단계도 줄이고 코드를 읽기 쉽게 만들 수 있다.

> 📃 **Note**

위 코드는 `if/else`구문을 사용하지만 reducer안에서 [switch문](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/switch)을 사용하는 것이 관례이다. 결과는 같지만 switch문을 읽기가 더 쉽다.

이 문서의 나머지 부분에서 다음과 같이 reducer 함수를 작성해보자:

```jsx
function tasksReducer(tasks, action) {
  switch (action.type) {
    case "added": {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case "changed": {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case "deleted": {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error("Unknown action: " + action.type);
    }
  }
}
```

다른 `case`안에서 선언된 변수들이 서로 충돌하지 않기 위해`case` 블럭을 모두 중괄호 `{` 와 `}`로 감싸는 걸 추천한다. 또한, 하나의 `case`는 보통 `return`으로 끝나야한다. 만약 `return`을 잊으면 이 코드는 다음 `case`에 빠지게 될 것이고, 이는 실수로 이어진다.

아직 switch 구문에 익숙하지 않다면, if/else를 사용하는 것도 전혀 지장없다.

### 🐳 DEEP DIVE

**왜 reducer이라고 부를까?**

reducer들이 비록 컴포넌트 안에 있는 코드의 양을 “줄여주긴” 하지만, 사실 배열에서 사용하는 [reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) 연산을 따서 지은 이름이다.

`reduce()`연산은 배열을 가지고 많은 값들을 하나의 값으로 “누적”할 수 있다:

```jsx
const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce((result, number) => result + number); // 1 + 2 + 3 + 4 + 5
```

이 `reduce`함수가 “reducer”로 알려져 있다. 지금까지의 결과 와 현재의 아이템 을 가지고, 다음 결과 를 반환한다. React reducer는 이 아이디어와 똑같은 예시이다. React reducer도 지금까지의 state 와 action 을 가지고 다음 state 를 반환한다. 이런 방식으로 시간이 지나면서 action들을 state로 모으게 된다.

심지어 `reduce()` 메서드를 `initialState`와 `actions` 배열을 사용해서 reducer로 최종 state를 계산할 수도 있다.

### Step 3: 컴포넌트에서 reducer사용하기

마지막으로, `tasksReducer`를 컴포넌트에 연결해야 한다. React에서 `useReducer` Hook을 import하자:

```jsx
import { useReducer } from "react";
```

그리고 `useState`를 `useReducer`로 바꾼다:

```jsx
const [tasks, setTasks] = useState(initialTasks); // --- 수정 전 ❌

const [tasks, dispatch] = useReducer(tasksReducer, initialTasks); // --- 수정 후 ⭕
```

`useReducer` Hook은 `useState`와 비슷하다. 초기 state 값을 전달해야 하고 그 결과로 state 값과 state 설정자 함수(useReducer의 경우 dispatch 함수)를 반환한다. 하지만 조금 다르다.

`useReducer` Hook은 두 개의 인자를 받는다:

1. reducer 함수
2. 초기 state

그리고 아래 내용을 반환한다:

1. state값
2. dispatch 함수 (사용자의 action을 reducer에 “전달”해주는 함수)

이제 완전히 연결됐다! reducer는 컴포넌트 파일 하단에 선언되어 있다:

```jsx
import { useReducer } from "react";
import AddTask from "./AddTask.js";
import TaskList from "./TaskList.js";

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

  function handleAddTask(text) {
    dispatch({
      type: "added",
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: "changed",
      task: task,
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: "deleted",
      id: taskId,
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case "added": {
      return [
        // 🚨 --- 원한다면 reducer를 다른 파일로 옮길수도 있다.
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case "changed": {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case "deleted": {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error("Unknown action: " + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: "Visit Kafka Museum", done: true },
  { id: 1, text: "Watch a puppet show", done: false },
  { id: 2, text: "Lennon Wall pic", done: false },
];
```

이렇게 분리하면 컴포넌트 로직을 더 쉽게 읽을 수 있다. 이제 이벤트 핸들러는 action을 전달하여 무슨 일이 일어났는지 만 지정하고, reducer 함수는 action에 대한 응답으로 state가 어떻게 변경되는지 결정한다.
